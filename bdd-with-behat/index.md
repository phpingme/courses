---
 head:
  title: "BDD with Behat"
 commands:
   - vendor/bin/behat
---

## Introduction

To develop a software is always about managing a lot of moving parts. And pretty often it gets messy, in a way that even a developer who wrote the code, cannot recover what is going on after 2-3 weeks the code was shipped.  It is an old problem and had a range of mature concepts around that helps to deal with in a sufficient way. Here we will try a BDD, and show how we can control a software's feature set and move quickly forwards using behat.



## Write Feature and Scenarios
The concept of **Feature** in BDD let us focus on a specific problem from a perspective of certain customer.  To describe this problem in a Feature form we need to provide 2 things:
 - Feature inroduction
 - Scenario

### Feature introduction
To introduce a Feature we use quite the same pattern we apply to describe a user story, namely:
```html
   In order to <achieve a goal>
   As <the stakeholder who wants the goal>
   I want <something>
```
For a developer the 3'd line is most likely always clear, it handles an outcome of implementation, like *Product could be ordered*, *Post has hidden comments*... But it's not always clear about first two lines, especially if stuff have to be implemented in a microservice scope, where a customer could be less personalizable.
Here is important to work with PO and apply a [Ubiquitous Language](http://martinfowler.com/bliki/UbiquitousLanguage.html) of a domain you are implementing.

### Scenario
**Scenario** is an essential part of the whole BDD process, they are the part that describe a behaviour of our software. Each Scenario follows the following *Given-When-Then* schema:
```html
  Given <initial state>
  When <apply a change to the state>
  Then <verify a changed state>
```

To start to write Features, let's first initiate environment where we want to write it.

```sh
    vendor/bin/behat --init
```

it creates a following tree structure:
```
```

Now let's create a first feature ```features/calculator.feature``` (you can do it with a write click on **features** folder) with a first Scenario:
```
Feature: Calculator
  In order to know the results of calculation
  As a user
  I want to get numbers calculated

 Scenario: Get the right calculation
   Given i need to calculate a Factorial of "5"
   When a execute a calculation
   Then i get "120" back.
```


> An actual Task, write the second scenario that checks factorial doesn't return a wrong result back.

### Solution
```
 Scenario: Don't get the wrong calculation
   Given i need to calculate a Factorial of "5"
   When i execute a calculation
   Then i don't get the "121" back.
```



```projecteditor+terminal
---
match_file:
  path: /features/calculator.feature
  match:
   - Then.*(don\'t|not|doesn\'t|didn\'t).*back
---
```

## Implementing test first

After we define our feature that describes a constraints of a factorial task. Lets implement a test for it and take an advantage of behat as well.
First of all, we need to convert our feature in a PHP form. For that, let's run:
```sh
  vendor/bin/behat --append-snippets
```
Out of 6 steps we get 4 methods in **features/bootstrap/FeatureContext.php**, that throws a **Pending** exception, where each method is responsible for a concrete one line in a Scenario.
We have to have the same *Given* and *Then* descriptions in both of our Scenarios, that's why behat apply the same methods in **FeatureContext** class for them, the only that is variable are arguments and that will be passed in as a method parameters.
And we have two different *When*, for them we get another to methods that have to separately check task passing or non passing.

To start implement the test, let's create an empty **Factorial** class in an application root. And make it look like this:
```php
<?php
// path: /Factorial.php

class Factorial {

	public function __invoke() {

	}

}

```


Try to run behat again, just execute ```vendor/bin/behat```, and see on STDOUT, it has to look smth. like this:
```
2 scenarios (2 pending)
6 steps (2 pending, 4 skipped)
```

First we want to do is resolve pending steps. To achieve it, we need to overwrite ```throw new PendingException();``` in our autogenerated ```features/bootstrap/FeatureContext.php``` with a real implementation. Let's start with the first method ```thereIsATaskToFindFactorialOf``` for a first **Given** step and put a code like this:
```php
<?php
...

    /**
     * @Given there is a task to find factorial of :arg1
     */
    public function thereIsATaskToFindFactorialOf($arg1)
    {
        $this->input = $arg1;
    }
```

Then we go to the following **When** step, controlled by ```theSolutionIs``` method, that can be implemented like this:
```php
  /**
   * @When a solution is equal to :arg1
   */
  public function aSolutionIsEqualTo($arg1)
  {
      $this->isEqual = ($arg1 === (new Factorial())($this->input));
  }
```

And now the the most nice part, checking whether the app we build run, the way we expect it. We will do it in a php7 way a take usage of ```assert()``` function(it needs an extra ```ini_set('assert.exception', 1)```).
```php
   /**
    * @Then i passed the task
    */
   public function iPassedTheTask()
   {
       ini_set('assert.exception', 1);
       assert($this->isEqual, new AssertionError('Factorial return a wrong result'));
   }
```
and for negotiation case:
```php
   /**
    * @Then i didn't pass the task
    */
   public function iPassedTheTask()
   {
       ini_set('assert.exception', 1);
       assert(!$this->isEqual, new AssertionError('Factorial have to return a proper result'));
   }
```

let's try to run it, the output now, have to look like this:
```
2 scenarios (1 passed, 1 failed)
6 steps (5 passed, 1 failed)
```

And as you see from 2 Scenarios, we have 1 that already pass. It's kinda freaky to see that smth. working without we implement anything, but from outside perspective it just right that factorial ships wrong results.

> It's quite obvious step that is still open, namely implementation of a factorial. To pass this course step, implement a Factorial and run behat in order to check that both from out 2 scenarios are passing.

```projecteditor+terminal
---
match_output:
  match:
   - 2 scenarios \(2 passed|3 scenarios \(3 passed
---
```

## Applying Scenario Outline

Now you now the basics. The rest of the course we make it more suitable for a daily work.
You may noticed that our feature scenarios is bit duplicated, even a autogenerated snipptes for a ```FeatureContext.php``` resolved it in a way that for 6 steps we got 4 methods, we can simply reduce it to 3.

To achieve it, we will use **Scenario Outline**. The general it could look like  following:
```html
  Scenario Outline: <Scenario Name>
    Given a step with <variable1>
    When add <variable2>
    Then we get <variableN>

    Examples:
    | variable1 | variable2 | ... | variableN  |
    | value11   | value12   | ... | variable1N |
    | value21   | value22   | ... | variable2N |
```

You just have to declare **Scenario Outline** instead of **Scenario** and provide and **Examples** block
in a table format.

Let's take a look how we can overwrite course feature.

```html
Scenario Outline: Calculate a Factorial
  Given an <input>
  When a solution is equal to <result>
  Then the outcome is <outcome>

  Examples:
    | input | result | outcome    |
    | 5     | 120    | 'right'    |
    | 5     | 121    | 'wrong'    |
    | 0     | 1      | 'right'    |
```
As you can see we can even extend with any other input/result/outcome combination and be flexible to edit this.
Each **Examples** row will be handled as separate Scenario, so the the whole test context will be reinitiated for each row respectively.

run ```vendor/bin/behat --append-snippets``` and you get just 3 methods to implement.

> To pass this course step, rewrite ```FeatureContext``` in a way that it passes the Scenario Outline, the resulted test run, have to output:  **3 scenarios (3 passed)**


```projecteditor+terminal
---
match_output:
  match:
   - 3 scenarios \(3 passed
match_file:
  path: /features/course.feature
  match:
   - Scenario [O|o]utline
---
```


## Role driven behaviour

After we learned how to write compact and at the same time powerful scenarios, let's take a look, at how we can apply different use cases in a different php test context files.

Let's create another feature, say for course manager who has to be able to publish/unpublish a course. For the sake of simplicity we will refer to the same Factorial implementation. Create ```features/admin.feature``` file and put the following content there:
```
Feature: Administration
  In order to learn about programming
  As an admin
  I want to be able to control a calculation appearance

 Scenario Outline: Activate/Deactivate Calculation
   Given there is a calculation of <calculation> of any random number
   When i apply <state> to it
   Then i get <outcome> for a calculation

   Examples:
   | calculation  | state         | outcome |
   | 'Factorial'  | 'deactivated' | 'error' |
   | 'Factorial'  | 'activated'   | 'value' |
   | 'Factorial'  | 'default'     | 'value' |

```

Here we want to apply different php test context file as for Calculation feature, because it has pretty much another perspective and in that way needs another logic for populating a context state.

For that case we create in an application root a ```behat.yml``` file and pass the default execution behaviour of behat in a way it's suites our feature definition.

```
default:
    suites:
        feature_features:
            paths:    [ %paths.base%/features ]
            filters:  { role: user }
            contexts: [ FeatureContext ]
        admin_features:
            paths:    [ %paths.base%/features ]
            filters:  { role: admin }
            contexts: [ AdminContext ]
```
You definetly have noticed a ```{ role: <role> }``` pattern applied to **filters**. The certain **role** corelates directly to role identifacations in a feature file definition:

```
Feature: ...
  In order to ...
  As an **admin**
  I want ...
```
An **admin** role in a ```As an admin``` line of a Feature head is a meaningful statement for our application specification, that can be used to apply a certain php test context to it.

now run
```bash
   vendor/bin/behat --init --role admin
```
and after ```AdminContext```used to be created append the snippets to it
```bash
   vendor/bin/behat --append-snippets --role admin
```

We get three predifined methods:
```php
<?php
  ...
  /**
   * @Given there is a calculation of :arg1 of any random number
   */
  public function thereIsACalculationOfOfAnyRandomNumber($arg1)
  ...
  /**
   * @When i apply :arg1 to it
   */
  public function iApplyToIt($arg1)
  ...
  /**
   * @Then i get :arg1 for a calculation
   */
  public function iGetForACalculation($arg1)
  ...
```

**Given** step implies initialisation of 2 variables, that we can provide like this:
```php
<?php

  public function thereIsACalculationOfOfAnyRandomNumber($arg1)
  {
     $this->calculationName = $arg1;
     $this->calculationInput = rand(0, 10);
  }
```

To implement a **When** step we need to map a human readable state spec into some more handy from a developer perspective, and then initiated a state that we will check in a **Then** step. This could be done in a following way:
```php
<?php

  public function iApplyToIt($arg1)
  {
    $argument = null;
    switch($arg1){
      case 'deactivated':
        $argument = false;
        break;
      case 'activated':
      default:
        $argument = true;
        break;
    }
    $this->calculationInstance = new $this->calculationName($argument);
  }
```

And a **Then** step. Before assert an expected outcome we also need to map a calculation result back to spec. We will define it like this:
```php
<?php

public function iGetForACalculation($arg1)
{
  $outcome = null;
  try {
    $outcome = is_int(call_user_func($this->calculationInstance, $this->calculationInput))?'value':null;
  } catch (Error $e) {
    $outcome = 'error';
  }

  assert($arg1 === $outcome);
}

```
You may wonder, why don't we provide a "ready to run" values and do all that mapping before/after. It's important to understand, that the spec, that we defined in a feature file, have to be also a reference for a non-tech persons like stakeholder, who may not be really comfortable with **boolens** and **Exceptions** and it will make a discussion about implementing a feature most probably less sufficient.

Further, all that mapping have to be a part of application core(and move away from test context), since definitions we met in a spec are applied as a part of Domain's Ubiquitous Language. But before that, we just place it our tests.

now run the tests:
```bash
   vendor/bin/behat --role admin
```

and the output have to be most likely like this:
```
...
3 scenarios (2 passed, 1 failed)
9 steps (8 passed, 1 failed)
```
> As Task extend our Factorial class Implementation so that it pass the tests.

### Solution
```php
<?php

class Factorial {

  public function __construct($activated = true)
  {
  	$this->activated = $activated;
  }

  public function __invoke($number, $factorial = 1)
  {
  	if(!$this->activated){
  		throw new Error('Factorial is deactivated');
  	}
  	return $this->calculate($number, $factorial);
  }

  private function calculate($number, $factorial) {
  	while($number > 0){
  		return $this->calculate($number - 1, $factorial * $number);
  	}
  	return $factorial;
  }
}
```

```projecteditor+terminal
---
match_output:
  match:
   - 3 scenarios \(3 passed
---
```

## Conclusion

It was a first filling of BDD in php, if you noticed some inconsistency in this course you a free to make a PR to this course on github.com/phpingme/courses
